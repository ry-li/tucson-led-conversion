<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Permissive CSP to allow loading content from CDNs and GitHub on strict hosts -->
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <title>Tucson LED Conversion Timeline</title>
    
    <!-- ERROR LOGGER: Prints errors to screen if app fails to load -->
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:0;left:0;width:100%;background:red;color:white;padding:20px;z-index:9999;font-family:monospace;border-bottom:2px solid white;';
            div.innerHTML = '<strong>App Error:</strong> ' + msg + '<br/><small>' + url + ':' + line + '</small>';
            document.body.appendChild(div);
            // Don't suppress default error
            return false;
        };
        console.log("App script loaded. initializing...");
    </script>

    <!-- Tailwind CSS (Play CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <!-- React & ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (Standalone) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    
    <!-- PapaParse for CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- Proj4js for Coordinate Conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.10.0/proj4.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #root { height: 100vh; display: flex; flex-direction: column; }
        .map-container { flex-grow: 1; width: 100%; z-index: 0; }
        /* Custom range slider styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(229, 231, 235, 0.5);
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Fallback loading message */
        #fallback-msg {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 1.2rem;
            color: #666;
            background: #f9fafb;
        }
    </style>
</head>
<body>
    <div id="root">
        <div id="fallback-msg">Initializing Application...<br/><span style="font-size:0.8em; margin-top:10px;">(If this message stays, check console for errors)</span></div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        console.log("React script started executing...");

        const DATA_URL = 'https://raw.githubusercontent.com/ry-li/tucson-led-conversion/refs/heads/main/data/LED_Inst.csv';
        const BOUNDARY_URL = 'https://raw.githubusercontent.com/ry-li/tucson-led-conversion/refs/heads/main/data/Jurisdictional_Boundaries_(JURISBND)_tucson.geojson';
        const STREETLIGHTS_URL = 'https://raw.githubusercontent.com/ry-li/tucson-led-conversion/cf31affc3c87300e92a991fce0e3c9e4475b89b0/data/Streetlights_-_City_of_Tucson_-_Open_Data.geojson';

        // --- Helper: Convert GeoJSON from EPSG:3857 to EPSG:4326 if needed ---
        const transformGeoJSON = (data) => {
            if (!data || !window.proj4) return data;

            const source = '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs';
            const dest = '+proj=longlat +datum=WGS84 +no_defs';

            // Check if transformation is actually needed (Coordinates > 180 imply meters)
            let needsTransform = false;
            const checkCoords = (coords) => {
                if (Array.isArray(coords[0])) return checkCoords(coords[0]);
                if (coords.length >= 2 && typeof coords[0] === 'number') {
                    if (Math.abs(coords[0]) > 180 || Math.abs(coords[1]) > 90) return true;
                }
                return false;
            };

            if (data.features && data.features.length > 0) {
                 const firstGeom = data.features[0].geometry;
                 if (firstGeom && firstGeom.coordinates) needsTransform = checkCoords(firstGeom.coordinates);
            }

            if (!needsTransform) return data;

            // Recursive function to transform coordinates
            const transformCoords = (coords) => {
                if (Array.isArray(coords[0])) {
                    return coords.map(transformCoords);
                } else if (coords.length >= 2 && typeof coords[0] === 'number') {
                    return proj4(source, dest, coords);
                }
                return coords;
            };

            const newData = JSON.parse(JSON.stringify(data));
            const processGeometry = (geometry) => {
                if (geometry && geometry.coordinates) geometry.coordinates = transformCoords(geometry.coordinates);
            };

            if (newData.type === 'FeatureCollection') {
                newData.features.forEach(f => processGeometry(f.geometry));
            } else if (newData.type === 'Feature') {
                processGeometry(newData.geometry);
            } else if (newData.type === 'Polygon' || newData.type === 'MultiPolygon') {
                processGeometry(newData);
            }

            return newData;
        };

        // --- Icons (Inline SVGs) ---
        const Icons = {
            MapPin: ({ className }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    <path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/>
                    <circle cx="12" cy="10" r="3"/>
                </svg>
            ),
            Play: ({ className, fill }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill={fill ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"/></svg>
            ),
            Pause: ({ className, fill }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill={fill ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
            ),
            RotateCcw: ({ className }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 2v6h6" /><path d="M3 13a9 9 0 1 0 3-7.7L3 8" /></svg>
            ),
            PlayCircle: ({ className }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>
            ),
            Github: ({ className }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36.5-8 3C6.77 2.16 3.66 1.76 2.5 3c-.5 1.5-.5 3.5 0 3.5A5.5 5.5 0 0 0 0 12c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
            )
        };

        const formatDateKey = (date, groupBy) => {
            const d = new Date(date);
            if (isNaN(d.getTime())) return null;
            if (groupBy === 'year') return `${d.getFullYear()}`;
            if (groupBy === 'month') return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
            if (groupBy === 'week') {
                const target = new Date(d.valueOf());
                const dayNr = (d.getDay() + 6) % 7;
                target.setDate(target.getDate() - dayNr + 3);
                const firstThursday = target.valueOf();
                target.setMonth(0, 1);
                if (target.getDay() !== 4) target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
                const weekNumber = 1 + Math.ceil((firstThursday - target) / 604800000);
                return `${d.getFullYear()}-W${String(weekNumber).padStart(2, '0')}`;
            }
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        };

        const App = () => {
            const [rawData, setRawData] = useState([]);
            const [groupedData, setGroupedData] = useState({});
            const [timeKeys, setTimeKeys] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [groupBy, setGroupBy] = useState('month'); 
            const [speed, setSpeed] = useState(500); 
            const [isMapReady, setIsMapReady] = useState(false);
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState(null);
            
            // Data States
            const [boundaryData, setBoundaryData] = useState(null);
            const [showBoundary, setShowBoundary] = useState(true);
            const [streetlightData, setStreetlightData] = useState(null);
            const [showStreetlights, setShowStreetlights] = useState(false);

            const mapRef = useRef(null);
            const markersLayerRef = useRef(null);
            const boundaryLayerRef = useRef(null);
            const streetlightsLayerRef = useRef(null);
            const playIntervalRef = useRef(null);

            const isAtEnd = timeKeys.length > 0 && currentIndex >= timeKeys.length - 1;

            // Fetch Data
            useEffect(() => {
                const fetchData = async () => {
                    try {
                        setIsLoading(true);
                        console.log("Fetching CSV...");
                        
                        // Fetch CSV
                        const response = await fetch(DATA_URL);
                        if (!response.ok) throw new Error('Failed to fetch CSV data: ' + response.statusText);
                        const csvText = await response.text();
                        
                        Papa.parse(csvText, {
                            header: true,
                            skipEmptyLines: true,
                            complete: (results) => {
                                console.log("CSV Parsed. Rows:", results.data.length);
                                const firstRow = results.data[0];
                                if (firstRow && (firstRow['Point Y'] === undefined || firstRow['Point X'] === undefined || firstRow['InstallDate'] === undefined)) {
                                    setError("CSV format error: Missing columns.");
                                } else {
                                    setRawData(results.data);
                                }
                                setIsLoading(false);
                            },
                            error: (err) => {
                                console.error("CSV Parse Error", err);
                                setError(`Parse Error: ${err.message}`);
                                setIsLoading(false);
                            }
                        });

                        // Fetch Boundary
                        try {
                            const boundaryResp = await fetch(BOUNDARY_URL);
                            if (boundaryResp.ok) {
                                const boundaryJson = await boundaryResp.json();
                                setBoundaryData(transformGeoJSON(boundaryJson));
                            }
                        } catch (bErr) { console.warn("Boundary fetch failed", bErr); }

                        // Fetch Streetlights
                        try {
                            const streetlightsResp = await fetch(STREETLIGHTS_URL);
                            if (streetlightsResp.ok) {
                                const slJson = await streetlightsResp.json();
                                setStreetlightData(transformGeoJSON(slJson));
                            }
                        } catch (slErr) { console.warn("Streetlight fetch failed", slErr); }

                    } catch (err) {
                        console.error("Network Error", err);
                        setError(`Network Error: ${err.message}`);
                        setIsLoading(false);
                    }
                };
                fetchData();
            }, []);

            // Init Map
            useEffect(() => {
                const mapContainer = document.getElementById('map');
                if (!mapContainer) return;
                
                // IMPORTANT: Cleanup existing map instance to prevent "Map container already initialized" crash
                if (mapRef.current) {
                    return; // Already initialized
                }

                try {
                    console.log("Initializing Leaflet map...");
                    const map = L.map('map', { preferCanvas: true }).setView([32.22, -110.97], 11);

                    // Panes
                    map.createPane('boundaryPane'); map.getPane('boundaryPane').style.zIndex = 390;
                    map.createPane('streetlightsPane'); map.getPane('streetlightsPane').style.zIndex = 400;
                    map.createPane('ledPane'); map.getPane('ledPane').style.zIndex = 410;
                    
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                        subdomains: 'abcd', maxZoom: 20
                    }).addTo(map);

                    boundaryLayerRef.current = L.geoJSON(null, {
                        pane: 'boundaryPane',
                        style: { color: '#ef4444', weight: 2, opacity: 0.6, fill: false, dashArray: '5, 5' }
                    }).addTo(map);

                    streetlightsLayerRef.current = L.geoJSON(null, {
                        pane: 'streetlightsPane', 
                        pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                            pane: 'streetlightsPane', radius: 2, fillColor: "#fbbf24", color: "#d97706", weight: 1, opacity: 0.8, fillOpacity: 0.8
                        })
                    }).addTo(map);
                    
                    markersLayerRef.current = L.layerGroup().addTo(map);
                    mapRef.current = map;
                    setIsMapReady(true);
                    
                    setTimeout(() => {
                        if(map) map.invalidateSize();
                    }, 100);

                } catch (e) {
                    console.error("Map Initialization Error:", e);
                    setError("Map failed to load: " + e.message);
                }

                // Cleanup function
                return () => {
                    if (mapRef.current) {
                        console.log("Cleaning up map instance");
                        mapRef.current.remove();
                        mapRef.current = null;
                        setIsMapReady(false);
                    }
                };
            }, []);

            // Auto-fit to Streetlights
            useEffect(() => {
                if (streetlightData && isMapReady && mapRef.current) {
                    const tempLayer = L.geoJSON(streetlightData);
                    const bounds = tempLayer.getBounds();
                    if (bounds.isValid()) {
                        mapRef.current.fitBounds(bounds, { paddingTopLeft: [50, 50], paddingBottomRight: [50, 350], animate: false });
                    }
                }
            }, [streetlightData, isMapReady]);

            // Layer Management
            useEffect(() => {
                if (!mapRef.current || !boundaryLayerRef.current) return;
                boundaryLayerRef.current.clearLayers();
                if (showBoundary && boundaryData) boundaryLayerRef.current.addData(boundaryData);
            }, [boundaryData, showBoundary, isMapReady]);

            useEffect(() => {
                if (!mapRef.current || !streetlightsLayerRef.current) return;
                streetlightsLayerRef.current.clearLayers();
                if (showStreetlights && streetlightData) streetlightsLayerRef.current.addData(streetlightData);
            }, [streetlightData, showStreetlights, isMapReady]);

            // Processing
            useEffect(() => {
                if (rawData.length === 0) return;
                const groups = {};
                const keys = new Set();
                rawData.forEach(row => {
                    const key = formatDateKey(row['InstallDate'], groupBy);
                    if (key) {
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(row);
                        keys.add(key);
                    }
                });
                const sortedKeys = Array.from(keys).sort();
                setGroupedData(groups);
                setTimeKeys(sortedKeys);
                setCurrentIndex(0);
                setIsPlaying(false);
            }, [rawData, groupBy]);

            // Render LED Markers
            useEffect(() => {
                if (!mapRef.current || !markersLayerRef.current || timeKeys.length === 0) return;
                const layer = markersLayerRef.current;
                layer.clearLayers();
                const pointsToRender = [];
                for (let i = 0; i <= currentIndex; i++) {
                    const key = timeKeys[i];
                    if (groupedData[key]) pointsToRender.push(...groupedData[key]);
                }
                pointsToRender.forEach(p => {
                    const lat = parseFloat(p['Point Y']);
                    const lng = parseFloat(p['Point X']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        L.circleMarker([lat, lng], {
                            pane: 'ledPane', radius: 3, fillColor: "#3b82f6", color: "#2563eb", weight: 1, opacity: 1, fillOpacity: 0.6
                        }).bindPopup(`<strong>Date:</strong> ${p['InstallDate']}<br/><strong>Lat:</strong> ${lat}<br/><strong>Lng:</strong> ${lng}`).addTo(layer);
                    }
                });
            }, [currentIndex, timeKeys, groupedData, isMapReady]);

            // Animation
            useEffect(() => {
                if (isPlaying) {
                    playIntervalRef.current = setInterval(() => {
                        setCurrentIndex(prev => {
                            if (prev >= timeKeys.length - 1) { setIsPlaying(false); return prev; }
                            return prev + 1;
                        });
                    }, speed);
                } else { clearInterval(playIntervalRef.current); }
                return () => clearInterval(playIntervalRef.current);
            }, [isPlaying, timeKeys, speed]);

            const togglePlay = () => {
                if (isPlaying) setIsPlaying(false);
                else {
                    if (isAtEnd) setCurrentIndex(0);
                    setIsPlaying(true);
                }
            };

            const getButtonConfig = () => {
                if (isPlaying) return { IconComp: Icons.Pause, title: "Pause", isFilled: true };
                if (isAtEnd) return { IconComp: Icons.RotateCcw, title: "Replay", isFilled: false };
                if (currentIndex === 0) return { IconComp: Icons.PlayCircle, title: "Start Autoplay", isFilled: false };
                return { IconComp: Icons.Play, title: "Resume", isFilled: true };
            };

            const buttonConfig = getButtonConfig();
            const IconComponent = buttonConfig.IconComp;

            const currentTotal = useMemo(() => {
                let count = 0;
                for (let i = 0; i <= currentIndex; i++) {
                    const key = timeKeys[i];
                    if (groupedData[key]) count += groupedData[key].length;
                }
                return count;
            }, [currentIndex, groupedData, timeKeys]);

            return (
                <div className="h-full flex flex-col relative overflow-hidden">
                    <div className="bg-white border-b border-gray-200 p-4 shadow-sm z-20 flex justify-between items-center">
                        <div>
                            <h1 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                                <Icons.MapPin className="w-5 h-5 text-blue-500" />
                                Tucson LED Conversion Timeline
                            </h1>
                            <div className="flex flex-col">
                                <p className="text-xs text-gray-500">{isLoading ? "Loading data..." : `Visualizing ${rawData.length} total points`}</p>
                                <p className="text-xs text-amber-600 font-medium mt-0.5">Note: data incomplete (covers through 11/8/2017, while conversions extend to 2018).</p>
                            </div>
                        </div>
                        <div className="flex items-center gap-3">
                             {isLoading && <div className="loader"></div>}
                             {error && <div className="text-red-500 text-sm font-medium">{error}</div>}
                        </div>
                    </div>

                    <div className="flex-grow relative">
                        <div id="map" className="w-full h-full absolute top-0 left-0 bg-gray-100"></div>
                        {rawData.length > 0 && !isLoading && (
                            <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 w-11/12 max-w-4xl glass-panel rounded-2xl p-4 shadow-xl z-[500] flex flex-col gap-4">
                                <div className="flex justify-between items-end">
                                    <div className="flex items-center gap-4">
                                        <button onClick={togglePlay} className={`w-12 h-12 flex items-center justify-center rounded-full text-white shadow-lg transition-all hover:scale-105 active:scale-95 ${isAtEnd && !isPlaying ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'}`} title={buttonConfig.title}>
                                            <IconComponent className="w-6 h-6" fill={buttonConfig.isFilled} />
                                        </button>
                                        <div>
                                            <div className="text-sm font-semibold text-gray-500 uppercase tracking-wider">Current Date</div>
                                            <div className="text-2xl font-bold text-gray-800 tabular-nums">{timeKeys[currentIndex] || '--'}</div>
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-3">
                                        <div className="bg-white/50 border border-gray-200 rounded-lg px-3 py-1 flex items-center gap-2">
                                            <span className="w-2 h-2 rounded-full bg-blue-500"></span>
                                            <span className="text-xs text-gray-500 uppercase font-semibold mr-2">Total Installed</span>
                                            <span className="text-lg font-bold text-blue-600 tabular-nums">{currentTotal}</span>
                                        </div>
                                        <select value={groupBy} onChange={(e) => setGroupBy(e.target.value)} className="bg-white border border-gray-300 text-gray-700 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 outline-none">
                                            <option value="day">Daily</option>
                                            <option value="week">Weekly</option>
                                            <option value="month">Monthly</option>
                                            <option value="year">Yearly</option>
                                        </select>
                                    </div>
                                </div>
                                <div className="w-full relative pt-2">
                                    <input type="range" min="0" max={Math.max(0, timeKeys.length - 1)} value={currentIndex} onChange={(e) => { setCurrentIndex(parseInt(e.target.value)); setIsPlaying(false); }} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                    <div className="flex justify-between text-xs text-gray-400 mt-1 font-mono"><span>{timeKeys[0]}</span><span>{timeKeys[timeKeys.length - 1]}</span></div>
                                </div>
                                <div className="flex items-center gap-6 border-t border-gray-200 pt-3 mt-1">
                                    <label className="flex items-center gap-2 cursor-pointer text-sm text-gray-600 select-none">
                                        <input type="checkbox" checked={showBoundary} onChange={(e) => setShowBoundary(e.target.checked)} className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"/>
                                        <span className="w-3 h-0.5 bg-red-500 border-b border-dashed border-red-500 inline-block mx-0.5"></span> City Limits
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer text-sm text-gray-600 select-none">
                                        <input type="checkbox" checked={showStreetlights} onChange={(e) => setShowStreetlights(e.target.checked)} className="w-4 h-4 text-amber-500 rounded focus:ring-amber-400"/>
                                        <span className="w-2 h-2 rounded-full bg-amber-500 inline-block mx-0.5"></span> Current Streetlights
                                        {streetlightData ? <span className="text-xs text-gray-400 ml-1">({streetlightData.features?.length})</span> : <span className="text-xs text-amber-500 ml-1 animate-pulse">Loading...</span>}
                                    </label>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    <footer className="bg-white border-t border-gray-200 py-2 px-4 z-20 flex flex-col items-center text-[10px] text-gray-500 gap-1">
                        <div className="flex flex-wrap justify-center items-center gap-3">
                            <div>&copy; {new Date().getFullYear()} <a href="https://r-li.com" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline font-medium">Ruoyu Li</a></div>
                            <div className="text-gray-300">|</div>
                            <div className="flex items-center gap-1"><Icons.Github className="w-3 h-3" /><span>Repo:</span><a href="https://github.com/ry-li/tucson-led-conversion" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline font-medium">ry-li/tucson-led-conversion</a></div>
                        </div>
                        <div className="text-center text-gray-400 leading-tight flex flex-wrap justify-center gap-x-1">
                            <span className="font-semibold">Data Sources:</span> 
                            <span>LED Conversion data from Tucson DOT</span>
                            <span className="text-gray-300 mx-1">&bull;</span>
                            <span>
                                <a href="https://data-cotgis.opendata.arcgis.com/datasets/cotgis::jurisdictional-boundaries-jurisbnd" target="_blank" rel="noopener noreferrer" className="hover:text-gray-600 underline decoration-dotted transition-colors">City Limits</a>
                                {' and '}
                                <a href="https://gisdata.tucsonaz.gov/datasets/cotgis::streetlights-city-of-tucson-open-data" target="_blank" rel="noopener noreferrer" className="hover:text-gray-600 underline decoration-dotted transition-colors">Streetlights</a> 
                                {' (Upd. Sept 8, 2025) from Tucson Open Data'}
                            </span>
                        </div>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>